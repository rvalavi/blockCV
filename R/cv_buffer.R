#' Use buffer around records to separate train and test folds (a.k.a. buffered/spatial leave-one-out)
#'
#' This function generates spatially separated train and test folds by considering buffers of
#' the specified distance (\code{size} parameter) around each observation point.
#' This approach is a form of \emph{leave-one-out} cross-validation. Each fold is generated by excluding
#' nearby observations around each testing point within the specified distance (ideally the range of
#' spatial autocorrelation, see \code{\link{cv_spatial_autocor}}). In this method, the testing set never
#' directly abuts a training sample (e.g. presence or absence; 0s and 1s). For more information see the details section.
#'
#' When working with presence-background (presence and pseudo-absence) species distribution
#' data (should be specified by \code{presence_bg = TRUE} argument), only presence records are used
#' for specifying the folds (recommended). Consider a target presence point. The buffer is defined around this target point,
#' using the specified range (\code{size}). By default, the testing fold comprises only the target presence point (all background
#' points within the buffer are also added when \code{add_bg = TRUE}).
#' Any non-target presence points inside the buffer are excluded.
#' All points (presence and background) outside of buffer are used for the training set.
#' The methods cycles through all the \emph{presence} data, so the number of folds is equal to
#' the number of presence points in the dataset.
#'
#' For presence-absence data (and all other types of data), folds are created based on all records, both
#' presences and absences. As above, a target observation (presence or absence) forms a test point, all
#' presence and absence points other than the target point within the buffer are ignored, and the training
#' set comprises all presences and absences outside the buffer. Apart from the folds, the number
#' of \emph{training-presence}, \emph{training-absence}, \emph{testing-presence} and \emph{testing-absence}
#' records is stored and returned in the \code{records} table. If \code{column = NULL} and \code{presence_bg = FALSE},
#' the procedure is like presence-absence data. All other data types (continuous, count or multi-class responses) should be
#' done by \code{presence_bg = FALSE}.
#'
#'
#' @inheritParams cv_spatial
#' @param column character; indicating the name of the column in which response variable (e.g. species data as a binary
#'  response i.e. 0s and 1s) is stored. This is required when \code{presence_bg = TRUE}, otherwise optional.
#' @param size numeric value of the specified range by which training/testing data are separated.
#' This distance should be in \strong{metres}. The range could be explored by \code{\link{cv_spatial_autocor}}.
#' @param presence_bg logical; whether to treat data as species presence-background data. For all other data
#' types (presence-absence, continuous, count or multi-class responses), this option should be \code{FALSE}.
#' @param add_bg logical; add background points to the test set when \code{presence_bg = TRUE}. We do not
#' recommend this according to Radosavljevic & Anderson (2014). Keep it \code{FALSE}, unless you mean to add
#' the background pints to testing points.
#' @param progress logical; whether to shows a progress bar.
#' @param report logical; whether to generate print summary of records in each fold; for very big
#' datasets, set to \code{FALSE} for faster calculation.
#'
#' @seealso \code{\link{cv_nndm}}, \code{\link{cv_spatial}}, and \code{\link{cv_spatial_autocor}}
#'
#' @references Radosavljevic, A., & Anderson, R. P. (2014). Making better Maxent models of species
#' distributions: Complexity, overfitting and evaluation. Journal of Biogeography, 41, 629â€“643. https://doi.org/10.1111/jbi.12227
#'
#' @return An object of class S3. A list of objects including:
#'     \itemize{
#'     \item{folds_list - a list containing the folds. Each fold has two vectors with the training (first) and testing (second) indices}
#'     \item{k - number of the folds}
#'     \item{size - the defined range of spatial autocorrelation)}
#'     \item{column - the name of the column if provided}
#'     \item{presence_bg - whether this was treated as presence-background data}
#'     \item{records - a table with the number of points in each category of training and testing}
#'     }
#' @export
#'
#' @examples
#' \donttest{
#' library(blockCV)
#'
#' # import presence-absence species data
#' points <- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
#' # make an sf object from data.frame
#' pa_data <- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)
#'
#' bloo <- cv_buffer(x = pa_data,
#'                   column = "occ",
#'                   size = 350000, # size in metres no matter the CRS
#'                   presence_bg = FALSE)
#'
#' }
cv_buffer <- function(
        x,
        column = NULL,
        size,
        presence_bg = FALSE,
        add_bg = FALSE,
        progress = TRUE,
        report = TRUE
){

    # check x is an sf object
    x <- .check_x(x)
    # is column in x?
    column <- .check_column(column, x)

    # x's CRS must be defined
    if(is.na(sf::st_crs(x))){
        stop("The coordinate reference system of 'x' must be defined.")
    }

    if(is.null(column) && presence_bg) stop("'column' must be provided for presence-background data.")


    # distance matrix by sf
    dmatrix <- sf::st_distance(x)
    units(dmatrix) <- NULL

    if(presence_bg){
        unqsp <- unique(x[, column, drop = TRUE])
        if(!is.numeric(unqsp) || any(unqsp < 0) || any(unqsp > 1)){
            stop("Presence-background option is only for species data with 0s (backgrounds/pseudo-absences) and 1s (presences).\n", "The data should be numeric.\n")
        }
        # indices of presences
        x_1s <- which(x[, column, drop = TRUE] == 1)
    } else{
        x_1s <- 1:nrow(x)
    }

    # the k
    n <- length(x_1s)

    # add background only if both true
    add_bg <- (presence_bg && add_bg)

    if(progress) pb <- utils::txtProgressBar(min = 0, max = n, style = 3)
    fold_list <- lapply(x_1s, function(i, pbag = add_bg){
        if(pbag){
            test_ids <- which(dmatrix[i, ] <= size)
            inside <- x[test_ids, column, drop = TRUE]
            test_set <- test_ids[which(inside == 0)]
            test_set <- c(test_set, i) # change this back
        } else{
            test_set <- i
        }
        if(progress) utils::setTxtProgressBar(pb, i)
        list(as.numeric(which(dmatrix[i, ] > size)),
             as.numeric(test_set))
    }
    )

    # calculate train test table summary
    if(report){
        train_test_table <- .ttt(fold_list, x, column, n)
        print(summary(train_test_table)[c(1,4,6), ])
    }

    final_objs <- list(
        folds_list = fold_list,
        k = n,
        column = column,
        size = size,
        presence_bg = presence_bg,
        records = if(report) train_test_table else NULL
    )

    class(final_objs) <- c("cv_buffer")
    return(final_objs)
}


#' @export
#' @method print cv_buffer
print.cv_buffer <- function(x, ...){
    print(class(x))
}

#' @export
#' @method plot cv_buffer
plot.cv_buffer <- function(x, ...){
    message("Please use cv_plot function to plot each fold.")
}

#' @export
#' @method summary cv_buffer
summary.cv_buffer <- function(object, ...){
    if(!is.null(object$records)){
        print(summary(object$records)[c(1,4,6),])
    }
}


# count the train and test records
.ttt <- function(fold_list, x, column, n){
    if(is.null(column)){
        tt_count <- base::data.frame(train = rep(0, n), test = 0)
        for(i in seq_len(n)){
            train_set <- fold_list[[i]][[1]]
            test_set <- fold_list[[i]][[2]]
            tt_count$train[i] <- length(train_set)
            tt_count$test[i] <- length(test_set)
        }
    } else{
        cl <- sort(unique(x[, column, drop = TRUE]))
        clen <- length(cl)
        .check_classes(clen, column) # column should be binary or categorical
        tt_count <- as.data.frame(matrix(0, nrow = n, ncol = clen * 2))
        names(tt_count) <- c(paste("train", cl, sep = "_"), paste("test", cl, sep = "_"))
        for(i in seq_len(n)){
            train_set <- fold_list[[i]][[1]]
            test_set <- fold_list[[i]][[2]]
            countrain <- table(x[train_set, column, drop = TRUE])
            countest <- table(x[test_set, column, drop = TRUE])
            tt_count[i, which(cl %in% names(countrain))] <- countrain
            tt_count[i, clen + which(cl %in% names(countest))] <- countest
        }
    }

    return(tt_count)
}
